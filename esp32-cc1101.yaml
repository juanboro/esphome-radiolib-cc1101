# Sample Configuration File

## enables CC1101 direct OOK receiver/transmit and creates a MQTT raw dumper

substitutions:
  # MQTT Credentials
  mqtt_host: !secret mqtt_host
  mqtt_remote_raw_topic: esphome/rawrf

external_components:
  - source:
      type: git
      url: https://github.com/juanboro/esphome-radiolib-cc1101

packages:
  # optionally enable controls to set/observe state
  cc1101_controls: !include cc1101-controls.yaml

# Update as needed
esphome:
  name: esp32-dev1
  friendly_name: ESP32 Dev Work

  platformio_options:
    lib_ldf_mode: "deep+" # only necessary for arduino platform
  libraries:
    - RadioLib

esp32:  
  board: esp32dev
  framework:
    # change as necessary - i find esp-idf a little less erratic
    type: esp-idf
#    type: arduino

wifi:
  ssid: !secret wifi_name
  password: !secret wifi_pass
  fast_connect: true

logger:
#  level: VERBOSE
  level: INFO
  
captive_portal:

mqtt:
  broker: ${mqtt_host}
  id: mqtt_client

web_server:
  port: 80

spi:
  # these are the default VSPI pins to use on ESP32
  clk_pin: 18   # CC1001 pin 5
  mosi_pin: 23  # CC1001 pin 6
  miso_pin: 19  # CC1001 pin 7

radiolib_cc1101:
  id: mycc1101
  cs_pin: 5 # CC1101 pin 4
  rx_pin:
    number: 32 # This is CC1101 GDO0 pin 3
    allow_other_uses: true
  tx_pin:
    number: 32 # This is also GDO0
    allow_other_uses: true
  # other optional settings.. (use control settings to verify they work and then set)
  filter: 468khz # RX filter BW (58-812kHz)
  bitrate: 40 # bitrate (0.025-600kbps)
  reg_agcctrl0: 0xb2 # agcctrol0 register setting
  reg_agcctrl1: 0x00 # agcctrol1 register setting
  reg_agcctrl2: 0xc7 # agcctrol2 register setting

remote_receiver:
  - id: rf_receiver
    idle: 10ms
    pin:
      number: 32 # This is also GDO0
      allow_other_uses: true
      id: cc1101_gd0_recv

#    dump: raw

    # mqtt publish ook pulse data that rtl_433 can decode as input for debugging
    # this will overwhelm an esp8266, and is kinda hacky but works... it would be nice
    # to know if there is a way to yield in esphome lambdas.  I'm guessing that would be
    # quite difficult though.
    #
    # on the receive side: 
    # stdbuf -o0 mosquitto_sub  -h <mqtthost> -I rx -t 'esphome/rawrf/#' | rtl_433 -r ook:-
    on_raw:
      then:
        - lambda: |-
            int rawcount=x.size();
            char buffer[512];

            int j=0;
            char* bufp=buffer;
            while (j<rawcount) {
              if (x[j]>0) {
                bufp+=sprintf(bufp,"%d %d\n",x[j],(j<rawcount-1) && (x[j+1]<0) ? -x[j+1] : 10000);
                ++j;
              }
              ++j;

              if ((bufp-buffer)>490) {
                  id(mqtt_client).publish("${mqtt_remote_raw_topic}", buffer);
                  bufp=buffer;
              }
            }
            sprintf(bufp,";end\n");
            id(mqtt_client).publish("${mqtt_remote_raw_topic}", buffer);

remote_transmitter:
  - id: rf_transmitter
    pin:
      number: 32 # This is also GDO0
      allow_other_uses: true
      id: cc1101_gd0_xmit
    on_transmit:
      then:
        - lambda: |-
            id(mycc1101).xmit();
            id(rf_transmitter).setup();
    on_complete:
      then:
        - lambda: id(mycc1101).recv();
    carrier_duty_percent: 100%

ota:
  platform: esphome
  on_begin:
    - lambda: id(mycc1101).standby();
